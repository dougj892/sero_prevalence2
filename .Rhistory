poststrat_ordered <- lapply(poststrat_ordered, factor)
ps_dummies <- dummyVars("~ .", data = poststrat_ordered)
ps_reshaped <- data.frame(predict(ps_dummies, newdata = poststrat_ordered))
# Convert the draws to a dataframe
draws <- as.data.frame(fit2) %>% select(-lp__)
# check the dimensions of both
dim(draws)
dim(ps_reshaped)
# Multiple draws * ps_reshaped'
draws.x <- data.matrix(draws)
ps_reshaped.x.t <- t(data.matrix(ps_reshaped))
# multiply draws times the transposed reshaped matrix
linpred <- draws.x %*% ps_reshaped.x.t
head(draws)
names(draws)
names(ps_reshaped)
posterior_predict_sero_noise <- function(i, draws, ...) {
draws$dpars$mu[, i]
}
# Generate predictions using the poststrat data
posterior_prob <- predict(fit2, newdata = poststrat, allow_new_levels = TRUE)
poststrat_prob <- posterior_prob[,1] %*% poststrat$N / sum(poststrat$N)
posterior_prob[1:10]
fit1 <- brm(
cat_pref ~ factor(male) + factor(male) * factor(age) +
(1 | state) + (1 | age) + (1 | eth) + (1 | income),
family = binomial(link = "logit"),
data = sample,
iter = 500,
chain = 2
)
cat(stancode(fit1), file = file.path(path, "brms_code.stan"))
model_data <- standata(fit1)
# Generate predictions using the poststrat data
posterior_prob <- predict(fit1, newdata = poststrat, allow_new_levels = TRUE)
poststrat_prob <- posterior_prob[,1] %*% poststrat$N / sum(poststrat$N)
glue("True pop prevalence: {round(true_popn_pref,3)}; estimate: {round(poststrat_prob, 3)}")
mean(sample$cat_pref)
ls(brms)
ls("package:brms")
predict.brmsfit
brmsfit.predict
?predict
library(tidyverse); library(rstan); library(glue); library(brms); library(caret)
path <- "C:/Users/dougj/Documents/code/sero_prevalence2"
source(file.path(path, "simulate_mrp_data_w_noise_random.R"))
sero_sim <- simulate_mrp_data(n=1000)
sample <- sero_sim[['sample']]
poststrat <- sero_sim[['poststrat']]
true_popn <- sero_sim[['true_popn']]
#set.seed(8675309)
se <- rbeta(1, tp, fn)
library(tidyverse); library(rstan); library(glue); library(brms); library(caret)
path <- "C:/Users/dougj/Documents/code/sero_prevalence2"
source(file.path(path, "simulate_mrp_data_w_noise_random.R"))
sero_sim <- simulate_mrp_data(n=1000)
sample <- sero_sim[['sample']]
poststrat <- sero_sim[['poststrat']]
true_popn <- sero_sim[['true_popn']]
# Data from evaluation of antibody test on samples with disease and negative controls
tp <- 90  # true positives - disease samples with correct test output
fn <- 10  # false negatives - disease samples with incorrect test output
tn <- 95  # true negatives - negative controls with correct test output
fp <- 5   # false positives - negative controls with incorrect test output
#set.seed(8675309)
se <- rbeta(1, tp, fn)
sp <- rbeta(1, tn, fp)
glue("Sensivity: {round(se, 2)}")
glue("Specificity: {round(sp, 2)}")
# Create binary vectors for whether the antibody test would give the correct result
# (Creating two vectors saves time because the assignment can then be easily vectorized)
pos_correct <- rbinom(n = 1000, size = 1, prob = se)
neg_correct <- rbinom(n = 1000, size = 1, prob = sp)
sample$test <- sample$cat_pref*pos_correct+(1-sample$cat_pref)*(1-neg_correct)
true_popn_pref <- sum(true_popn$cat_pref * poststrat$N) / sum(poststrat$N)
predict.
predict.R
predict
library(tidyverse); library(rstan); library(glue); library(brms); library(caret)
path <- "C:/Users/dougj/Documents/code/sero_prevalence2"
source(file.path(path, "simulate_mrp_data_w_noise_random.R"))
sero_sim <- simulate_mrp_data(n=1000)
sample <- sero_sim[['sample']]
poststrat <- sero_sim[['poststrat']]
true_popn <- sero_sim[['true_popn']]
# Data from evaluation of antibody test on samples with disease and negative controls
tp <- 90  # true positives - disease samples with correct test output
fn <- 10  # false negatives - disease samples with incorrect test output
tn <- 95  # true negatives - negative controls with correct test output
fp <- 5   # false positives - negative controls with incorrect test output
#set.seed(8675309)
se <- rbeta(1, tp, fn)
sp <- rbeta(1, tn, fp)
glue("Sensivity: {round(se, 2)}")
glue("Specificity: {round(sp, 2)}")
# Create binary vectors for whether the antibody test would give the correct result
# (Creating two vectors saves time because the assignment can then be easily vectorized)
pos_correct <- rbinom(n = 1000, size = 1, prob = se)
neg_correct <- rbinom(n = 1000, size = 1, prob = sp)
sample$test <- sample$cat_pref*pos_correct+(1-sample$cat_pref)*(1-neg_correct)
true_popn_pref <- sum(true_popn$cat_pref * poststrat$N) / sum(poststrat$N)
fit1 <- brm(
cat_pref ~ factor(male) + factor(male) * factor(age) +
(1 | state) + (1 | age) + (1 | eth) + (1 | income),
family = binomial(link = "logit"),
data = sample,
iter = 500,
chain = 2
)
cat(stancode(fit1), file = file.path(path, "brms_code.stan"))
model_data <- standata(fit1)
# Generate predictions using the poststrat data
posterior_prob <- predict(fit1, newdata = poststrat, allow_new_levels = TRUE)
poststrat_prob <- posterior_prob[,1] %*% poststrat$N / sum(poststrat$N)
glue("True pop prevalence: {round(true_popn_pref,3)}; estimate: {round(poststrat_prob, 3)}")
sero_noise <- custom_family(
"sero_noise",
links = c("logit"),
type = "int"
)
?
stan_funs <- glue("
real sero_noise_lpmf(int y, real mu) {{
real pt;
pt = mu*{tp/(tp+fn)}+(1-mu)*({tn/(tn+fp)});
return bernoulli_lpmf(y | pt);
}}
real sero_noise_rng(real mu) {{
return bernoulli_rng(mu);
}}
")
stanvars <- stanvar(scode = stan_funs, block = "functions")
sero_noise <- custom_family(
"sero_noise",
links = c("logit"),
type = "int"
)
?
stan_funs <- glue("
real sero_noise_lpmf(int y, real mu) {{
real pt;
pt = mu*{tp/(tp+fn)}+(1-mu)*({tn/(tn+fp)});
return bernoulli_lpmf(y | pt);
}}
real sero_noise_rng(real mu) {{
return bernoulli_rng(mu);
}}
")
stanvars <- stanvar(scode = stan_funs, block = "functions")
?
stan_funs <- glue("
real sero_noise_lpmf(int y, real mu) {{
real pt;
pt = mu*{tp/(tp+fn)}+(1-mu)*({tn/(tn+fp)});
return bernoulli_lpmf(y | pt);
}}
real sero_noise_rng(real mu) {{
return bernoulli_rng(mu);
}}
")
stan_funs
stan_funs
?
stan_funs <- glue("
real sero_noise_lpmf(int y, real mu) {{
real pt;
pt = mu*{tp/(tp+fn)}+(1-mu)*({tn/(tn+fp)});
return bernoulli_lpmf(y | pt);
}}
real sero_noise_rng(real mu) {{
return bernoulli_rng(mu);
}}
")
stan_funs
sero_noise <- custom_family(
"sero_noise",
links = c("logit"),
type = "int"
)
stan_funs <- glue("
real sero_noise_lpmf(int y, real mu) {{
real pt;
pt = mu*{tp/(tp+fn)}+(1-mu)*({tn/(tn+fp)});
return bernoulli_lpmf(y | pt);
}}
real sero_noise_rng(real mu) {{
return bernoulli_rng(mu);
}}
")
stanvars <- stanvar(scode = stan_funs, block = "functions")
fit2 <- brm(
test | trials(1) ~ factor(male) + factor(male) * factor(age) +
(1 | state) + (1 | age) + (1 | eth) + (1 | income),
family = sero_noise,
data = sample, stanvars = stanvars,
chains = 2,
iter = 300
)
brms:::predict
brms:::predict.brmsfit
library(sloop)
ftype(predict)
?restructure
?posterior_predict
posterior_prob <- fitted(fit2, newdata = poststrat, allow_new_levels = TRUE)
posterior_predict_sero_noise <- function(i, draws, ...) {
draws$dpars$mu[, i]
}
posterior_prob <- fitted(fit2, newdata = poststrat, allow_new_levels = TRUE)
posterior_predict_sero_noise <- function(i, draws, ...) {
draws$dpars$mu[, i]
}
# Generate predictions using the poststrat data
posterior_prob <- predict(fit2, newdata = poststrat, allow_new_levels = TRUE)
poststrat_prob <- posterior_prob[,1] %*% poststrat$N / sum(poststrat$N)
posterior_prob
# test out the predict function on existing data
test <- predict(fit2)
test
head(test)
poststrat$Age_Gen <- poststrat$male*7+poststrat$age
# Reshape the poststrat dataframe to be composed of dummies
poststrat_ordered <- poststrat[c("male", "Age_Gen", "state", "age", "eth", "income")]
poststrat_ordered <- lapply(poststrat_ordered, factor)
ps_dummies <- dummyVars("~ .", data = poststrat_ordered)
ps_reshaped <- data.frame(predict(ps_dummies, newdata = poststrat_ordered))
# Convert the draws to a dataframe
draws <- as.data.frame(fit2) %>% select(-lp__)
# check the dimensions of both
dim(draws)
dim(ps_reshaped)
# Multiple draws * ps_reshaped'
draws.x <- data.matrix(draws)
ps_reshaped.x.t <- t(data.matrix(ps_reshaped))
# multiply draws times the transposed reshaped matrix
linpred <- draws.x %*% ps_reshaped.x.t
draws
names(draws)
?brm
?stanvars
sero_noise <- custom_family(
"sero_noise",
links = c("logit"),
type = "int"
)
stan_funs <- glue("
real sero_noise_lpmf(int y, real mu) {{
real pt;
pt = mu*{tp/(tp+fn)}+(1-mu)*({tn/(tn+fp)});
return bernoulli_lpmf(y | pt);
}}
real sero_noise_rng(real mu) {{
return bernoulli_rng(mu);
}}
")
stanvars <- stanvar(scode = stan_funs, block = "functions")
fit2 <- brm(
test | trials(1) ~ factor(male) + factor(male) * factor(age) +
(1 | state) + (1 | age) + (1 | eth) + (1 | income),
family = sero_noise,
data = sample, stanvars = stanvars,
chains = 2,
iter = 300,
save_all_pars = TRUE
)
# test out the predict function on existing data
test <- predict(fit2)
test
# Convert the draws to a dataframe
draws <- as.data.frame(fit2) %>% select(-lp__)
names(draws)
View(draws)
draws1 <- as.data.frame(fit1) %>% select(-lp__)
View(draws1)
s3_dispatch(predict(fit2))
?predict.brmsfit
predict.brmsfit
predict.brmsfit()
posterior_predict
?predict
s3_dispatch(predict(fit2))
?predict.brmsfit
predict.brmsfit
brms:::predict.brmsfit()
brms:::predict.brmsfit
s3_get_method(predict())
s3_get_method(predict
)
s3_get_method(predict)
s3_get_method(posterior_predict)
View(draws)
rowMeans(draws)
rowMeans(draws1)
inv.logit(rowMeans(draws))
# take the inverse logit of the linear predictor and then weight up
inv.logit <- function(x) 1/(1+exp(-x))
inv.logit(rowMeans(draws))
library(tidyverse); library(rstan); library(glue); library(brms); library(caret)
path <- "C:/Users/dougj/Documents/code/sero_prevalence2"
source(file.path(path, "simulate_mrp_data_w_noise_random.R"))
sero_sim <- simulate_mrp_data(n=1000)
sample <- sero_sim[['sample']]
poststrat <- sero_sim[['poststrat']]
true_popn <- sero_sim[['true_popn']]
# Data from evaluation of antibody test on samples with disease and negative controls
tp <- 90  # true positives - disease samples with correct test output
fn <- 10  # false negatives - disease samples with incorrect test output
tn <- 95  # true negatives - negative controls with correct test output
fp <- 5   # false positives - negative controls with incorrect test output
#set.seed(8675309)
se <- rbeta(1, tp, fn)
sp <- rbeta(1, tn, fp)
glue("Sensivity: {round(se, 2)}")
glue("Specificity: {round(sp, 2)}")
# Create binary vectors for whether the antibody test would give the correct result
# (Creating two vectors saves time because the assignment can then be easily vectorized)
pos_correct <- rbinom(n = 1000, size = 1, prob = se)
neg_correct <- rbinom(n = 1000, size = 1, prob = sp)
sample$test <- sample$cat_pref*pos_correct+(1-sample$cat_pref)*(1-neg_correct)
true_popn_pref <- sum(true_popn$cat_pref * poststrat$N) / sum(poststrat$N)
cat(stancode(fit2), file = file.path(path, "brms_code2.stan"))
sero_noise <- custom_family(
"sero_noise",
links = c("logit"),
type = "int"
)
stan_funs <- glue("
real sero_noise_lpmf(int y, real mu) {{
real pt;
pt = mu*{tp/(tp+fn)}+(1-mu)*({tn/(tn+fp)});
return bernoulli_lpmf(y | pt);
}}
real sero_noise_rng(real mu) {{
return bernoulli_rng(mu);
}}
")
stanvars <- stanvar(scode = stan_funs, block = "functions")
fit2 <- brm(
test | trials(1) ~ factor(male) + factor(male) * factor(age) +
(1 | state) + (1 | age) + (1 | eth) + (1 | income),
family = sero_noise,
data = sample, stanvars = stanvars,
chains = 2,
iter = 300,
save_all_pars = TRUE
)
cat(stancode(fit2), file = file.path(path, "brms_code2.stan"))
model_data <- standata(fit1)
library(tidyverse); library(rstan); library(glue); library(brms); library(caret)
path <- "C:/Users/dougj/Documents/code/sero_prevalence2"
source(file.path(path, "simulate_mrp_data_w_noise_random.R"))
sero_sim <- simulate_mrp_data(n=1000)
sample <- sero_sim[['sample']]
poststrat <- sero_sim[['poststrat']]
true_popn <- sero_sim[['true_popn']]
# Data from evaluation of antibody test on samples with disease and negative controls
tp <- 90  # true positives - disease samples with correct test output
fn <- 10  # false negatives - disease samples with incorrect test output
tn <- 95  # true negatives - negative controls with correct test output
fp <- 5   # false positives - negative controls with incorrect test output
#set.seed(8675309)
se <- rbeta(1, tp, fn)
sp <- rbeta(1, tn, fp)
glue("Sensivity: {round(se, 2)}")
glue("Specificity: {round(sp, 2)}")
# Create binary vectors for whether the antibody test would give the correct result
# (Creating two vectors saves time because the assignment can then be easily vectorized)
pos_correct <- rbinom(n = 1000, size = 1, prob = se)
neg_correct <- rbinom(n = 1000, size = 1, prob = sp)
sample$test <- sample$cat_pref*pos_correct+(1-sample$cat_pref)*(1-neg_correct)
true_popn_pref <- sum(true_popn$cat_pref * poststrat$N) / sum(poststrat$N)
fit1 <- brm(
cat_pref ~ factor(male) + factor(male) * factor(age) +
(1 | state) + (1 | age) + (1 | eth) + (1 | income),
family = binomial(link = "logit"),
data = sample,
iter = 500,
chain = 2
)
cat(stancode(fit), file = file.path(path, "brms_code.stan"))
# Define the custom family to add to BRMs
sero_noise <- custom_family(
"sero_noise",
links = c("logit"),
type = "int"
)
stan_funs <- glue("
real sero_noise_lpmf(int y, real mu) {{
real pt;
pt = mu*{tp/(tp+fn)}+(1-mu)*({1-(tn/(tn+fp))});
return bernoulli_lpmf(y | pt);
}}
real sero_noise_rng(real mu) {{
return bernoulli_rng(mu);
}}
")
stanvars <- stanvar(scode = stan_funs, block = "functions")
fit2 <- brm(
test | trials(1) ~ factor(male) + factor(male) * factor(age) +
(1 | state) + (1 | age) + (1 | eth) + (1 | income),
family = sero_noise,
data = sample, stanvars = stanvars,
chains = 2,
iter = 300,
save_all_pars = TRUE
)
cat(stancode(fit2), file = file.path(path, "brms_code2.stan"))
model_data2 <- standata(fit2)
posterior_prob <- fitted(fit2, newdata = poststrat, allow_new_levels = TRUE)
posterior_predict_sero_noise <- function(i, draws, ...) {
draws$dpars$mu[, i]
}
# test out the predict function on existing data
test <- predict(fit2)
# Generate predictions using the poststrat data
posterior_prob <- predict(fit2, newdata = poststrat, allow_new_levels = TRUE)
poststrat_prob <- posterior_prob[,1] %*% poststrat$N / sum(poststrat$N)
test
mean(test)
true_popn_pref
mean(sample$test)
shinystan::launch_shinystan(fit2)
# The posterior predict function uses the predicted value of the prevalence.
# This is Ok as long as we are just seeking point estimates, but if we
posterior_predict_sero_noise <- function(i, draws, ...) {
# draws$dpars$mu[, i]
binomial(draws$dpars$mu[, i])
}
# test out the predict function on existing data
test <- predict(fit2)
# The posterior predict function uses the predicted value of the prevalence.
# This is Ok as long as we are just seeking point estimates, but if we
posterior_predict_sero_noise <- function(i, draws, ...) {
# draws$dpars$mu[, i]
rbinom(draws$dpars$mu[, i])
}
# test out the predict function on existing data
test <- predict(fit2)
rbinom(1, 10)
rbinom(1, 10, .5)
library(tidyverse); library(rstan); library(glue); library(brms); library(caret)
path <- "C:/Users/dougj/Documents/code/sero_prevalence2"
source(file.path(path, "simulate_mrp_data_w_noise_random.R"))
sero_sim <- simulate_mrp_data(n=1000)
sample <- sero_sim[['sample']]
poststrat <- sero_sim[['poststrat']]
true_popn <- sero_sim[['true_popn']]
# Data from evaluation of antibody test on samples with disease and negative controls
tp <- 90  # true positives - disease samples with correct test output
fn <- 10  # false negatives - disease samples with incorrect test output
tn <- 95  # true negatives - negative controls with correct test output
fp <- 5   # false positives - negative controls with incorrect test output
#set.seed(8675309)
se <- rbeta(1, tp, fn)
sp <- rbeta(1, tn, fp)
glue("Sensivity: {round(se, 2)}")
glue("Specificity: {round(sp, 2)}")
# Create binary vectors for whether the antibody test would give the correct result
# (Creating two vectors saves time because the assignment can then be easily vectorized)
pos_correct <- rbinom(n = 1000, size = 1, prob = se)
neg_correct <- rbinom(n = 1000, size = 1, prob = sp)
sample$test <- sample$cat_pref*pos_correct+(1-sample$cat_pref)*(1-neg_correct)
true_popn_pref <- sum(true_popn$cat_pref * poststrat$N) / sum(poststrat$N)
fit1 <- brm(
cat_pref ~ factor(male) + factor(male) * factor(age) +
(1 | state) + (1 | age) + (1 | eth) + (1 | income),
family = binomial(link = "logit"),
data = sample,
iter = 500,
chain = 2
)
cat(stancode(fit1), file = file.path(path, "brms_code1.stan"))
model_data <- standata(fit1)
# Generate predictions using the poststrat data
posterior_prob <- predict(fit1, newdata = poststrat, allow_new_levels = TRUE)
poststrat_prob <- posterior_prob[,1] %*% poststrat$N / sum(poststrat$N)
glue("True pop prevalence: {round(true_popn_pref,3)}; estimate: {round(poststrat_prob, 3)}")
# Define the custom family to add to BRMs
sero_noise <- custom_family(
"sero_noise",
links = c("logit"),
type = "int"
)
stan_funs <- glue("
real sero_noise_lpmf(int y, real mu) {{
real pt;
pt = mu*{tp/(tp+fn)}+(1-mu)*({1-(tn/(tn+fp))});
return bernoulli_lpmf(y | pt);
}}
real sero_noise_rng(real mu) {{
return bernoulli_rng(mu);
}}
")
stanvars <- stanvar(scode = stan_funs, block = "functions")
fit2 <- brm(
test | trials(1) ~ factor(male) + factor(male) * factor(age) +
(1 | state) + (1 | age) + (1 | eth) + (1 | income),
family = sero_noise,
data = sample, stanvars = stanvars,
save_all_pars = TRUE
)
cat(stancode(fit2), file = file.path(path, "brms_code2.stan"))
model_data2 <- standata(fit2)
posterior_predict_sero_noise <- function(i, draws, ...) {
draws$dpars$mu[, i]
}
# test out the predict function on existing data
test <- predict(fit2)
# Generate predictions using the poststrat data
posterior_prob <- predict(fit2, newdata = poststrat, allow_new_levels = TRUE)
# The posterior predict function uses the predicted value of the prevalence. This is Ok as long as we are just seeking point estimates. To fully account for uncertainty, we should draw from binom(N, p = posterior_prob[i])
poststrat_prob <- posterior_prob[,1] %*% poststrat$N / sum(poststrat$N)
