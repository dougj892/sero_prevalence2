"0","NQ <- 20"
"0","varnames <- c(""pt_sample_true"", ""pt_sample_posterior"", ""pt_pop_true"", ""pt_pop_posterior"", ""pt_rank_stat"", ""pa_sample_true"", ""pa_sample_posterior"", ""se"", ""se_posterior"", ""sp"", ""sp_posterior"", ""pt_hat"", ""pt_hat_se"", ""pt_simple"", ""pt_simple_se"")"
"0",""
"0","mc_results <- as.data.frame(array(NA, c(NQ, length(varnames))))"
"0","names(mc_results) <- varnames"
"0","for (q in 1:NQ) {"
"0",""
"0","sero_sim <- simulate_mrp_data(n=1000)"
"0","sample <- sero_sim[['sample']]"
"0","poststrat <- sero_sim[['poststrat']]"
"0","true_popn <- sero_sim[['true_popn']]"
"0",""
"0","# Data from evaluation of antibody test on samples with disease and negative controls "
"0","tp <- 90  # true positives - disease samples with correct test output"
"0","fn <- 10  # false negatives - disease samples with incorrect test output"
"0","tn <- 95  # true negatives - negative controls with correct test output"
"0","fp <- 5   # false positives - negative controls with incorrect test output"
"0",""
"0","#set.seed(8675309)"
"0","se <- rbeta(1, tp, fn)"
"0","sp <- rbeta(1, tn, fp)"
"0","glue(""Sensivity: {round(se, 2)}"")"
"0","mc_results$se[q] <- se"
"0","glue(""Specificity: {round(sp, 2)}"")"
"0","mc_results$sp[q] <- sp"
"0",""
"0","# Create binary vectors for whether the antibody test would give the correct result"
"0","# (Creating two vectors saves time because the assignment can then be easily vectorized)"
"0","pos_correct <- rbinom(n = 1000, size = 1, prob = se)"
"0","neg_correct <- rbinom(n = 1000, size = 1, prob = sp)"
"0",""
"0","sample$test <- sample$cat_pref*pos_correct+(1-sample$cat_pref)*(1-neg_correct)"
"0",""
"0",""
"0","mc_results$pa_sample_true[q] <- mean(sample$test)"
"0","mc_results$pt_sample_true[q] <- mean(sample$cat_pref)"
"0",""
"0","glue(""Specificity: {round(sp, 2)}"")"
"0",""
"0","# Calculate the true population prevalence"
"0","true_popn_pref <- sum(true_popn$cat_pref * poststrat$N) / sum(poststrat$N)"
"0","glue(""True prevalance: {round(true_popn_pref, 3)}"")"
"0",""
"0","mc_results$pt_pop_true[q] <- true_popn_pref"
"0",""
"0","# Fit the modified MRP model to the data"
"0","# Create a new variable that is 1+male since Stan expects sex to be {1,2}^N"
"0","poststrat$sex <- poststrat$male+1"
"0","ps_reordered <- poststrat[c('sex', 'age', 'income', 'state', 'eth', 'N')] %>% "
"0","  arrange(eth, state, income, age, sex)"
"0",""
"0","# Create an array using contents of ps_reordered to pass to Stan"
"0","P <- array(data = ps_reordered$N, "
"0","             dim=head(as.numeric(lapply(ps_reordered, function(x) length(unique(x)))),-1), "
"0","             dimnames=lapply(ps_reordered[,1:(length(ps_reordered)-1)], unique))"
"0",""
"0","# check that P was assigned correctly by looking at the value of N for a random row"
"0","dim(P)"
"0","P[1, 3, 2, 45, 2]"
"0","ps_reordered %>% filter((sex == 1) & (age == 3) & (income == 2) & (state == 45) & (eth == 2))"
"0",""
"0","# Gather the data in a list"
"0","mmrp_data <-  list(N = nrow(sample),"
"0","                   ng_age = length(unique(ps_reordered$age)),"
"0","                   ng_income = length(unique(ps_reordered$income)),"
"0","                   ng_state = length(unique(ps_reordered$state)),"
"0","                   ng_eth = length(unique(ps_reordered$eth)),"
"0","                   sex = sample$male+1,"
"0","                   age = sample$age,"
"0","                   income = sample$income,"
"0","                   eth = sample$eth,"
"0","                   state = sample$state, "
"0","                   y = sample$cat_pref,"
"0","                   P = P,"
"0","                   tp = tp,  "
"0","                   fn = fn,"
"0","                   tn = tn,"
"0","                   fp = fp)"
"0",""
"0",""
"0","mmrp_fit <- stan("
"0","  file = file.path(path, ""mrp_with_uncertainty_with_beta_bin.stan""),"
"0","  data = mmrp_data, "
"0","  iter = 1000, chains = 3"
"0","  )"
"0",""
"0","# Inspect Stan output and compare to the true population figures and the unweighted sample figures."
"0","mmrp_draws <- extract(mmrp_fit)"
"0",""
"0","mc_results$se_posterior[q] <- mean(mmrp_draws$se)"
"0",""
"0","mc_results$sp_posterior[q] <- mean(mmrp_draws$sp)"
"0",""
"0","mc_results$pt_pop_posterior[q] <- mean(mmrp_draws$phi)"
"0",""
"0","mc_results$pa_sample_posterior[q] <- mean(rowMeans(mmrp_draws$pa))"
"0",""
"0","mc_results$pt_sample_posterior[q] <- mean(rowMeans(mmrp_draws$pt))"
"0",""
"0","mc_results$pt_rank_stat[q] <- mean(mmrp_draws$phi > true_popn_pref)"
"0",""
"0","# Generate estimates using the ad hoc, strata based procedure. Since there are too many strata if we include state and age, drop those variables."
"0",""
"0","# collapse the sample and poststrat data on state"
"0","sample_collapsed <- sample %>% "
"0","  group_by(male, eth, income) %>% "
"0","  summarize(pt_total = sum(cat_pref), pa_total = sum(test), n = n())"
"0",""
"0","poststrat_collapsed <- poststrat %>% "
"0","  group_by(male, eth, income) %>% "
"0","  summarize(N = sum(N))"
"0",""
"0","# merge with poststrat collapsed -- note that there are "
"0","res <- sample_collapsed %>% left_join(poststrat_collapsed, by = c(""male"", ""eth"", ""income""), keep.all = TRUE)"
"0",""
"0",""
"0","# Add columns for the output from epi.prev"
"0","res <- res %>% mutate(prev = NA, lower = NA, upper= NA)"
"0",""
"0","# For each strata, calculate the prevalence and confidence interval."
"0","# I used a level of 68% since that should roughly correspond to a width of 2 standard deviations"
"0","for (i in 1:nrow(res)) {"
"0","  temp <- epi.prev(res$pa_total[i], res$n[i], "
"0","         se = tp/(tp+fn), sp=tn/(tn+fp),  conf.level=.68, method = ""c-p"", units =1 )"
"0","  res$prev[i] <- temp$tp$est"
"0","  res$lower[i] <- temp$tp$lower"
"0","  res$upper[i] <- temp$tp$upper"
"0","}"
"0",""
"0","# Calculate the weighted mean and variance"
"0","NT <- sum(res$N)"
"0","res <- res %>% mutate(y = N*prev/NT, s=(upper-lower)/2, v=((s*N/NT)^2)/n )"
"0",""
"0","pt_hat <- sum(res$y)"
"0","pt_hat_se=sum(res$v)^.5"
"0",""
"0","mc_results$pt_hat[q] <- pt_hat"
"0","mc_results$pt_hat_se[q] <- pt_hat_se"
"0",""
"0","# calculate pt_simple -- the really simple estimate of pt"
"0","NT <- sum(res$N)"
"0","pa_simple <- sum(res$pa_total*res$N*(1/res$n))/NT"
"0","se_hat <-  tp/(tp+fn)"
"0","sp_hat <- tn/(tn+fp)"
"0","mc_results$pt_simple[q] <- (pa_simple+sp_hat-1)/(se_hat+sp_hat-1)"
"0","write_csv(poststrat, file.path(path, paste(""mcr1"", Sys.Date(), "".csv"")))"
"0","}"
"2","recompiling to avoid crashing R session
"
"1","
"
"1",""
"1","SAMPLING"
"1",""
"1"," FOR MODEL '"
"1",""
"1","mrp_with_uncertainty_with_beta_bin"
"1",""
"1","' NOW (CHAIN "
"1",""
"1","1"
"1",""
"1",").
"
"1","Chain "
"1","1"
"1",": "
"1",""
"1","
"
"1","Chain "
"1","1"
"1",": "
"1","Gradient evaluation took 0.002 seconds"
"1","
"
"1","Chain "
"1","1"
"1",": "
"1","1000 transitions using 10 leapfrog steps per transition would take 20 seconds."
"1","
"
"1","Chain "
"1","1"
"1",": "
"1","Adjust your expectations accordingly!"
"1","
"
"1","Chain "
"1","1"
"1",": "
"1",""
"1","
"
"1","Chain "
"1","1"
"1",": "
"1",""
"1","
"
"1","Chain "
"1","1"
"1",": "
"1","Iteration:   1 / 1000 [  0%]  (Warmup)"
"1","
"
"1","Chain "
"1","1"
"1",": "
"1","Iteration: 100 / 1000 [ 10%]  (Warmup)"
"1","
"
"1","Chain "
"1","1"
"1",": "
"1","Iteration: 200 / 1000 [ 20%]  (Warmup)"
"1","
"
"1","Chain "
"1","1"
"1",": "
"1","Iteration: 300 / 1000 [ 30%]  (Warmup)"
"1","
"
"1","Chain "
"1","1"
"1",": "
"1","Iteration: 400 / 1000 [ 40%]  (Warmup)"
"1","
"
